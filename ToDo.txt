- Unificar las excepciones. Todas las excepciones que se lanzan desde un constructor deberian ser TypeinitializationException (y dentro el subtipo - Argumento, ArgumentNull...-)


- Añadir la gestión de Amendment Information
	-> Añadir la clase con dos campos:
		- oldMandateId (Ok)
		- oldBankAccount (Ok)
	-> Testear que se aceptan:
		- Cualquiera de los dos puede ser nulo, incluso ambos. (Ok)
		- Si se especifica, MandateID no puede ser cadena vacía o solo espacios (Ok)
		- Si se especifica, oldBankAccount nopuede tener un IBAN invalido (Ok)
	-> Incluir el campo AmendmentInformation en DirectdebitTransaction:
		- Testear que se puede crear un DirectDebitTransaction con AmendmendInformation nulo o que tenga componentes nulos.
			* En DirectDebitRemmitanceUnitTests (Ok)
			* En DirectDebitRemmitanceManagerTests (Ok)
		- Comprobar que se crean correctamente las clase serializables (SEPAElementsGenerator y SEPAElementsGeneratorUnitTests)
			* AmendmentInformationDetails6 (Ok)
			* DirectDebitTransactionInformation9 gestiona bien el AmendmentInformation (Ok)
			* Mirar los casos: (Ok)
				-> Cambio de cuenta en el mismo banco se pone el nuevo banco (Etiqueta <OrgnlDbtrAcct>)
				-> Cambio de cuenta a otro banco NO se pone el nuev banco, sino SMNDA en <OrgnlDbtrAgt>
			* Tests de SEPAElementsGenerator
		- Comprobar la serializazion (pruebas en ISO20022PaymentInitiations):
			* De un AmendmentInformationDetails6 es necesario, o basta mirar el DirectDebitTransactionInformation9 siguiente?
			* De un DirectDebitTransactionInformation9 que incluya amendment information ('DirectDebitTransactionInfo.xml')
			* El campo <AmdmntInd> solo debería aparecer si es TRUE. Si es 'false' es innecesario
- Añadir a la gestión de los adeudos el campo FRST
	-> Añadir a DirectDebitTransaction el campo booleano 'First' (modificar los test unitarios de DirectDebitTransaction para que comprueben este valor)
	-> Comprobar si existe AmendmentInformation al instanciar DirectDebitTransaction
		-> Si hay cambio de BANCO es obligatorio que se considere 'FRST'
	-> Añadir a DirectDebitPaymentInstruction el campo 'First'
	-> Al añadir un DirectDebitTransaction a DirectDebitPaymentInstruction comprobar si se corresponden 'RCUR' o 'FRST'
		* En el método .AddRejectedTransactionToTransactionsGroupPaymentReject
		* Al crear una instancia de DirectDebitTransacionsGroupPayment con una lista de DirectDebitTransaction incluida
	-> Comprobar que se crea correctamente un CustomerDirectDebitInitiation con los DirectDebitPaymentInstruction 'FRST' y 'RCUR'
- Completar los tests de SEPAElementsGenerator (creacion de clases serializables para el ENVIO)
- Completar los tests de SEPAElementsReader (lectura de las clases deserializadas de una devolucíon)
- En este punto debemos haber testeados los 3 veles:
	-> Las clases serializables crean nodos XML conformes con es esquema  ---> Test de ISO20022PaymentInitiations
	-> Los objetos serializables se crean bien a partit de los DirectDebitElements (al crear una remesa) y el reves (al leer una devolucion)  ---> Tests de SEPAElementGenerator y SEPAElementsReader
	-> Los DirectDebitElements funcionan bien  ---> Tests de DirectDebitElements
- Dejamos <CtgryPurp>? Lo pondríamos SIEMPRE a 'TRAD'.
- Al deserializar un PaymentStatusReport, hay que revisar los contenidos de(que campos existen y sus valores), para diferenciar entre Devolucion y Rechazo
- Serializar a UTF-8?
- Realizar un test de CARGA: Generar unos ficheros de prueba de CustomerDirectDebitInitiation de 100, 500, 1000, 3000 y 6000 adeudos, a ver si 'peta' por falta de memoria o va muy lento.
	-> ¡OJO! El PC de desarrollo tiene 16 gigas. Controlar el uso de memoria (preguntar en 'stackoverflow')
	-> ¡OJO! El PC de desarrollo es RAPIDO. Hay que estimar cuanto tardaría en un PC normal
	-> Los test hay que marcarlos para que no se ejecuten mas que cuando se pidan lanzar individualmente. Podemos probar a DESACTIVARLOS, y activarlos solo para la ocasión.
- Si en los test nos comemos la memoria, pensar una alternativa:
	-> Probar a eliminar la clase 'BankAccount' y quedarnos con un simple 'string' que contenga el IBAN.
	-> Simplificar la clase DirectdebitMandate para que solo contenga un MandateID, la fecha de creación del mismo, y un 'string' con el IBAN.
	-> En el momento de inicializar la serializacion tenemos DOS copias completas de cada remesa en memoria:
		* Los DirectDebitElements: Un DirectDebitRemittance con su lista de DirectDebitPaymentInstrucions, cada una con su lista de DirectDebitTransations
		* Los objetos ISO20022 serializables: Un CustomerDirectDebitInitiationV02 con su array de PaymentInstructionInformation4 cada uno con un array de DirectDebitTransactionInformation9 
		Podemos probar a:
			* Destruir (set=nothing) el DirectDebitRemittance una vez creado el CustomerDirectdebitInitiationV02.
			* Ir destruyendo los DirectDebitElements a medida que vamos creando su equivalente ISO20022
	-> Si aún así no tira
		-> Crear paso a paso cada elemento DirectDebit, luego convertir a clase ISO20022, serializar a nodo XML, y añadir el nodo al XMLDocument, de esta manera:
			* Primero se crea la estructura basica: un Documento con un CustomerDirectDebitInitiation (y los datos de GroupHeader) los PaymentInstruction necesarios (y los datos de Payment Identification)
			* Luego se van añadiendo uno a uno los DirectDebitTransactions, añadiendo los nodos al documento XML
			* Las sumas de control se pueden poner desde el principio o dejar vacíos. ¡OJO! ¡Esto significa que no deben saltar las excepciones de las sumas de control!
	-> ¿Leer directamente de un DataSet e ir creando directamente las instancias de las clases serializables, pasando por alto todo el trabajo que hemos hecho con DirectDebitElements? Sería una putada...
- ¿Hacer que todas las instanciaciones de objetos DirectDebitElements pasen a través de una clase o clases controladoras?
	-> Internamente:
		- SEPAMessagesManager usa:
			* DirectDebitRemittancesManager y PaymentStatusReportManager para acceder a las clases DirectDebitElements
			* SEPAElementsReader y SEPAElementsGenerator para acceder a las clases serializables de ISO20022
		- SEPAElementsGenerator y SEPAElementsReader deben usar DirectdebitRemittancesaManager y PaymentStatusReport? Quizá NO... Podria acceder directamente a las clases DirectDebit Elements
		- DirectDebitRemittancesManager tiene métodos para cerar y gestionar SOLO las clases principales:
			* DirectDebitTransaction
			* DirectDebitPaymentInstruction
			* DirectDebitRemittance
		- PaymentStatusReport tiene métodos para cerar y gestionar SOLO las clases principales:
			* DirectDebitTransactionReject
			* DirectDebitPaymentInstructionReject
			* PaymentStatusReport
	-> Externamente:
		- Con la estructura anterior sigue siendo necesario acceder directamente (sin pasar por 'Manager') a muchos elementos. ¿Cambiarlo?:
			 * 'Billing' (Debtor, SimplifiedBill...)
			 * 'DirectDebitElements' (BankAccount, DirectdebitInitiationContract, DirectdebitMandate)
		













	 
